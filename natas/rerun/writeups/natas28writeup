Holy shit. What a level...

This one is entirely different from all the others -- specifically because of the star of the level: encryption!

Upon opening natas28 you're presented with a page: 'Whack Computer Joke Database".

In the center is a search bar, upon which searching returns 3 jokes.

The first thing I noticed after searching, was that the extension 'search.php/?query=' was added.

The second thing I noticed was the string after...

With nothing but 'a' in the search bar inputted, I get the result 'G%2BglEae6W%2F1XjA7vRm21nNyEco%2Fc%2BJ2TdR0Qp8dcjPKriAqPE2%2B%2BuYlniRMkobB1vfoQVOxoUVz5bypVRFkZR5BPSyq%2FLC12hqpypTFRyXA%3D'

for the GET field 'query'.

What the fuck...?

That began the multi week process of figuring out how to exploit this level.

Playing with the 'query' field by hand, I sent 'query=a'. In return I got an error from search.php: 'Incorrect amount of PKCS#7 padding for blocksize'
Albeit very confusing at the time, this piece of information is vital.

Going forward, I sent in 'a' again and worked with the response it produced.

Taking in the massive 'query', I tried to use a tool pointed out to me called 'CyberChef'.

CyberChef lets you create 'recipes' to encrypt/decrypt/encode/decode an input however you would like.

After url decoding the query, and using base64 (which returns no errors), what is left is an unreadable mess.

I was presented with the guiding question 'if you wanted to take raw bytes and present them into a readable form, what would you use?'

I then decided to convert that data into readable hex bytes.

hex bytes output of search query 'a'
1b e8 25 11 a7 ba 5b fd 57 8c 0e ef 46 6d b5 9c 
dc 84 72 8f dc f8 9d 93 75 1d 10 a7 c7 5c 8c f2 
ab 88 0a 8f 13 6f be b9 89 67 89 13 24 a1 b0 75 
bd fa 10 54 ec 68 51 5c f9 6f 2a 55 44 59 19 47 
90 4f 4b 2a bf 2c 2d 76 86 aa 72 a5 31 51 c9 70


Before continuing with the hex bytes, lets go back to the 'PKCS#7' error, what does that tell us?

PKCS#7 upon looking it up, is one of the 'Public Key Cryptography Standards". This tells us that the massive 'query' string is in fact some sort of encrypted piece of information.

To continue getting more information from those hex bytes, I need to figure out what type of encryption is being used.

The types of encryption are Symmetric (one shared key), and Asymmetric (two keys, public/private).

Underneath symmetric encryption, you have 'block ciphers' which always encrypts the plaintext into a cipher with a length that is *always* a multiple of the blocksize.

After submitting multiple queries, the response in hex as always split into blocks of 16 bytes. Perhaps that is unclear based off of the one example above, but that is what I was able to gather.

16 bytes * 8 = 128 bits, so we have a 128 bit block cipher of some kind, but which one specifically?

Due to the key size (128 bit), the cipher would logically be AES, which typically uses 128 bit keys.

Next, the question becomes what is the mode of operation? (and what is a mode of operation)

So the cipher itself, is 128bits. meaning if you had the message 'abcdefghijklmnop', which is 16 bytes (128 bits), each bit of the key would encrypt each letter/byte 1-to-1.

What happens when you have a message that is longer than the cipher? The answer to that question is determined by the mode of operation.

To be more specific, a mode of operation determines what happens to an encrypted message when there is more than 1 block of information to encrypt.

Upon looking up a list of modes of operation for block ciphers, you get a few:

- ECB
- CBC
- PCBC
- CFB
- OFB
- CTR
- GCM

Lo and behold, the one mode of operation you should almost *NEVER* use is ECB or 'electronic codebook'

The reason is because the same block of plaintext will always encrypt to the same ciphertext, and does not change based off of the other blocks of data. 
As such, data patterns become extremely visible with ECB.
Most infamously, look up the 'ECB' penguin. It is crazy.

Anyway, knowing this is the most insecure mode of operation, how can you figure out if this is the mode of operation for this level?

Essentially, the bytes

1b e8 25 11 a7 ba 5b fd 57 8c 0e ef 46 6d b5 9c <-- here
dc 84 72 8f dc f8 9d 93 75 1d 10 a7 c7 5c 8c f2 <-- here
ab 88 0a 8f 13 6f be b9 89 67 89 13 24 a1 b0 75 
bd fa 10 54 ec 68 51 5c f9 6f 2a 55 44 59 19 47 
90 4f 4b 2a bf 2c 2d 76 86 aa 72 a5 31 51 c9 70 <-- and here

after sending different inputs of the same length don't change at all.

If it were a different mode of operation, the input in the middle of the plaintext to be encrypted would alter the entire encrypted response would change.

Instead, different inputs of length 1 only visibly alter the third row of bytes.

So great, the encryption type is AES ECB! Although AES is as of today a secure cipher, ECB is not at all secure.

Knowing that, how could we go about recovering the plaintext?

Well, the first step is identifying where your input is in the bytes sent in the response. Specifically, how many bytes are before and after your input?

Upon testing multiple searches, there are two observations to make that help with this:

the first two blocks *never* change based off of input or length of input, meaning that your input is at least 32 bytes into the response.

next, the last block only changes after length of input, which is due to the padding (part of the PKCS#7 standard).

For figuring out the number of bytes before:

	The approach I took was to send a query with 2 parts:
		- 32 bytes, composed of two identical 16-byte messages
		- an adjustable buffer of bytes that goes before the 2 indentical blocks

	What this does is allow me to figure out the number of bytes before. Since ECB encrypts the same block the same way, 2 blocks of the same input should be visible
	Because of this behavior, you can send bytes that slowly increase the number of bytes before the identical block. Once the correct buffer size is sent,
	there will be two identical blocks in the response that you can see.
	
	I wrote a utility I called 'querytohex' in python that lets me send a query with a string input, dumping the response in hex split blocks
	The specific query I then used was 'BUFFERBYTESbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'
	After sending 10 'a's in the buffer, the identical blocks revealed themselves, visible below (lines 3 & 4)
	Adding the 32 bytes of the unchanging first 2 lines, and counting back 16 - the 10 bytes from the buffer in line 2,
	you can see that my input is 38 (32+6) bytes into the response.

	 __________________________________________________________________
	|$python querytohex.py "aaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"|
	|a: 10 b: 32 c: 0 other: 0					   |
	|0: 1be82511a7ba5bfd578c0eef466db59c				   |
	|1: dc84728fdcf89d93751d10a7c75c8cf2				   |
	|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~			   |
	|2: c0872dee8bc9 | 0b1156913b08a223a39e				   |
	|3: 88a7bd72cda247dae1c3219f054b2e60				   |
	|4: 88a7bd72cda247dae1c3219f054b2e60				   |
	|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~			   |
	|5: 738a5ffb4a4500246775175ae596bbd6				   |
	|6: f34df339c69edce11f6650bbced62702				   |
	|__________________________________________________________________|


For figuring out the number of bytes after:
	
	Going back to the PKCS#7 error, we know that this encryption is using PKCS#7 style padding.

	Specifically, that is why the last block (which contains the padding) changes only based off of the length of the input.

	If you read up on it, PKCS#7 padding works this way for 16 byte blocks:
		block_length-(plaintext_length % block_length) assigns the number of bytes of padding

	In this case, 16-(# of bytes in the last block) = padding_length
	
	The last block is then the bytes left over + padding_length in hex * the length of the padding.
	
	For example if the last block just contained 'a', the padding would be

	16-1 (a is one byte) = 15 bytes of padding.

	The last block would then be 'a' + fifteen bytes of '0F' or "fifteen" in hex.

	Knowing that we can identify the number of bytes after by counting the number of bytes with no input:
	 _______________________________________
	|$python getbytes/querytohex.py ""	|
	|a: 0 b: 0 c: 0 other: 0		|
	|0: 1be82511a7ba5bfd578c0eef466db59c	|
	|1: dc84728fdcf89d93751d10a7c75c8cf2	|
	|2: e87ff60c99ad | 72ccbd947e3417a90128	|
	|3: a77e8ed1aabe0b5d05c4ffe6ac1423ab	|
	|4: 478eb1a1fe261a2c6c15061109b3feda	|
	|_______________________________________|

	Now add the maximum number of bytes so that the block size doesn't increase, which ends up being 3.
	(Sent 12 'a's)
	 ____________________________________________
	|python getbytes/querytohex.py "aaaaaaaaaaaa"|
	|a: 12 b: 0 c: 0 other: 0		     |
	|0: 1be82511a7ba5bfd578c0eef466db59c	     |
	|1: dc84728fdcf89d93751d10a7c75c8cf2	     |
	|2: c0872dee8bc9 | 0b1156913b08a223a39e	     |
	|3: ce82a9553b65b81280fb6d3bf2900f47	     |
	|4: 75fd5044fd063d26f6bb7f734b41c899	     |
	|____________________________________________|

	For another whole block to be added, the last block would have to contain 16 bytes of data (thereby adding a 16 byte block of entirely padding to the response).
	Since another block was *not* added, that means the last block is 15 bytes + 1 byte of padding.
	
	We also know that we have 12 bytes of input, with the last 2 being at the beginning of block '3'
	that means there are 14 (16-2) bytes of non-input plaintext in block 3, and the 15 in block 4.
	Adding them together, you get 14+15, or 29 bytes of data *after* the input!

In conclusion, 38 bytes before, 29 bytes after.

Now that we know this, what is the next step forward?

With that knowledge, you can actually begin to decipher the plaintext through a cheeky little method.

Since we know exactly where our input is, we can do something to decipher the input:

I'll work through this step by step to with this level as an example to hopefully explain it clearly.


Since (AES) ECB blocks are encrypted the exact same way, you can do something sneaky.

First, I will send a query with 10 a's, and 16 b's. The 10 a's fill out the third block of plaintext so I know the fourth line of hex is all my own input (16 b's).
_____________________________________________________________
$ python getbytes/querytohex.py "aaaaaaaaaabbbbbbbbbbbbbbbb"
a: 10 b: 16 c: 0 other: 0
0: 1be82511a7ba5bfd578c0eef466db59c
1: dc84728fdcf89d93751d10a7c75c8cf2
2: c0872dee8bc9|: 0b1156913b08a223a39e
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
3: 88a7bd72cda247dae1c3219f054b2e60
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4: 738a5ffb4a4500246775175ae596bbd6
5: f34df339c69edce11f6650bbced62702
_____________________________________________________________


Line '3' contains '88a7bd72cda247dae1c3219f054b2e60', which is the 16 b's.

by sending 10 a's and *15* b's instead, the first byte of plaintext that isn't our input is mixed into the block with the 15 b's.

Thus, the block to be encrypted will be 'bbbbbbbbbbbbbbb?' where ? is the unknown plaintext.

_____________________________________________________________
python getbytes/querytohex.py "aaaaaaaaaabbbbbbbbbbbbbbb"
a: 10 b: 15 c: 0 other: 0
0: 1be82511a7ba5bfd578c0eef466db59c
1: dc84728fdcf89d93751d10a7c75c8cf2
2: c0872dee8bc9|: 0b1156913b08a223a39e
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
3: 508f19c27764e316847804cfa959901e
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4: a09522f301cf9d36ac7023f165948c5a
5: 9739cd90522fa7a86f95773b56f9f8c0
_____________________________________________________________

In the encrypted response, line 3 now becomes '508f19c27764e316847804cfa959901'.

Now, instead of 10 a's and 15 b's, you can send 10 a's and 15 b's plus a random character.

If you find the same character as the first byte of the unknown plaintext, you will get the same encrypted block!

Using this method you're able to find the first character, which ends up being '%'.

(Looking for 3 to be '508f19c27764e316847804cfa959902')
___________________________________________________________
python getbytes/querytohex.py "aaaaaaaaaabbbbbbbbbbbbbbb%"
a: 10 b: 15 c: 0 other: 1
0: 1be82511a7ba5bfd578c0eef466db59c
1: dc84728fdcf89d93751d10a7c75c8cf2
2: c0872dee8bc9|: 0b1156913b08a223a39e
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
3: 508f19c27764e316847804cfa959901e
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4: 738a5ffb4a4500246775175ae596bbd6
5: f34df339c69edce11f6650bbced62702
___________________________________________________________

As you can see in the above example, sending 10 a's, 15 b's, and % makes the encrypted line the same.

Knowing the first character is a % told me that this is some kind of SQL query that is searching for jokes using 'like %', similar to how the password was built in natas17.

Using this method, you can slowly decrease the number of b's and build up the plaintext.

Unfortunately, you can only decrypt the first character in the front before it stops working... why?

Well, after the % is likely going to be a quote from the way SQL syntax is usually built.

It would appear that natas28 is in fact escaping characters which sucks... but instead of going from the front, why not hit it from the back.

This can be done exactly the same way, except you create a line with padding based off of your length of input on TOP of the 16 b's.

you then slowly increase the number of b's to push the data back into the last block with the padding.

Then you test characters in your own fake 'padding' block to see if you get an equal encrypted block.

Doing this nets you two characters, '3;' before running into another character that gets escaped.

All in all, it looks like the encrypted string in '/?query=' is this:

'38 bytes' + 'escaped_user_input' + '%.........3;'

Thinking back to the very beginning, 3 jokes are outputted onto the webpage of natas28 when you do a search, random each time.

To construct the final sql query, I put all the information together and made a guess:

'SELECT * FROM jokes WHERE joke LIKE '%userinput_escaped%' ORDER BY RAND() LIMIT 3;'

Selecting all jokes from the joke where the joke is like the user input, ordering them randomly and limiting the input by 3!

This ends up being exactly 38 bytes before the user input, and very close to 29 after....

Now with all this information, how can you attack the level...?


We're able to get our own perfectly encrypted query due to the way ECB works, padding and all

Because of that, we can pass a command like 'SELECT * FROM jokes;' and get a response in bytes WITH padding.

I wrote a python utility similar to the querytohex one.

This one converts my input to bytes with a buffer, adds the padding necessary in byte format, and sends it to natas28.

It then receives the /?query= field and converts it to bytes.
___________________________________________________________________________
$ python injectresponse.py 'SELECT * FROM jokes;' yes
bytearray(b'aaaaaaaaaaSELECT * FROM jokes;\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c')
0: 1be82511a7ba5bfd578c0eef466db59c
1: dc84728fdcf89d93751d10a7c75c8cf2
2: c0872dee8bc90b1156913b08a223a39e
3: eaf50dd768f1418c5dde5c5fd3d3c08c
4: 2d7fa1ef85d8ae14574d11bfd46b7d5b
5: 738a5ffb4a4500246775175ae596bbd6
6: f34df339c69edce11f6650bbced62702
____________________________________________________________________________

Viewing this, we know exactly where our input would be: after line 2, and before line 5.

'eaf50dd768f1418c5dde5c5fd3d3c08c2d7fa1ef85d8ae14574d11bfd46b7d5b'

Together, line 3 and 4 yield those bytes. Converting them from hex to bytes, encoding them with base64, and url encoding them nets this:

'6vUN12jxQYxd3lxf09PAjC1%2Foe%2BF2K4UV00Rv9RrfVs%3D'

and sending that to natas28 as the query:

'https://natas28.natas.labs.overthewire.org/search.php/?query=6vUN12jxQYxd3lxf09PAjC1%2Foe%2BF2K4UV00Rv9RrfVs%3D'

Displays EVERY joke!!!! Very exciting, we can now send any kind of MySQL query we want (minus quotes!).


Now what query do we send to get the password for natas29?

Well... if you send a query that isn't from the jokes table you get:

'Undefined index: joke in /var/www/natas/natas28/search.php on line 92'

Seems like you need a response that is a 'joke' to get anything.

There is also the matter of where natas29's information is stored.

Fortunately, you can test this out using a similar query to the time-based sql injection level.
Knowing that in previous levels there was a 'users' table with 'username' and 'password' columns...

If you send 'SELECT IF(COUNT(username)>0, SLEEP(5), SLEEP(0)) from users;'

The response takes over 5 seconds, meaning that there is in fact a 'username' column and a 'users' table.

You can do the same with 'password'.

Ok, so now how do we view the data from that table???

If you send 'SELECT username FROM users;' you get the same 'joke' index error, same goes for password.

So maybe if you pass off those fields as 'jokes' instead? 

Fortunately, there are 'aliases' in MySQL that allow you to do just that.

They allow you to make a query like this:

'SELECT username AS joke FROM users AS jokes;'

Doing so nets you the response 'natas29'. OH MY GOD!
Sending:

'SELECT password AS joke FROM users AS jokes;'
You get: 'airooCaiseiyee8he8xongien9euhe8b'!!!!

That's it!!!!!!!

natas29:airooCaiseiyee8he8xongien9euhe8b


What a fantastic level. Very difficult, but very informative!

