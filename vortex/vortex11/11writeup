Finally! A heap exploit level.

The idea of this level is to overwrite a 'pginfo' struct,
causing the returned value of the final 'malloc' to point to a location
we wantj

┌───────────────────────── vortex11 (main) ──────────────────────────┐
   #include <stdio.h>
   #include <string.h>
   
   
   int main(int argc, char **argv) {
           char *p;
           char *q;
           char *r;
           char *s;
           if (argc < 3)
           {
                   exit(0);
           }
           //Allocate 'large' chunk page (with 2 chunks, each 2048 bytes)
           p = (char *) malloc(0x800);
           //Allocate 'tiny' chunk page, which will contain a 
           //new pginfo struct
           q = (char *) malloc(0x10);
           //Allocate the 2nd chunk in the 'large' page
           r = (char *) malloc(0x800);
           //Overflow the 2nd large chunk by 8 bytes, allowing
           //us to set the page/shift/bits field of the struct
           strcpy(r , argv[1]);
           //We now control the following tiny chunk allocation,
           //allowing us to write to an arbitrary memory location 
           s = (char *) malloc(0x10);
           strncpy(s , argv[2], 0xf);
           exit(0);
   }
└────────────────────────────────────────────────────────────────────┘

 Diagram of the heap during the exploit:

┌─ Page 1 (large page) ─┐
│                       │
│  p (large chunk 1)    │
│     0x800             │ ─> Allocated first (new page) ┐
│                       │                               │
│ ───────────────────── │                               │
│                       │                               │
│  r (large chunk 2)    │<┐ Third allocation            │
│     0x800             │ │ Now writing to 'r'          │
│                       │ │ allows for overwriting      │
└┐                     ┌┘ │ of the PGINFO struct        │
 │ ─ Page 2 (tny pg) ─ │  │                             │
┌┘                     └┐ │ The next 'tiny' heap alloc  │
│  ┌  PGINFO STRUCT  ┐  │ │ is now at a controllable    │
│  │  PGINFO STRUCT  │  │ │ location                    │
│  └  PGINFO STRUCT  ┘  │ │                             │
│ ───────────────────── │ │                             │
│ │q│  │  │  │  │  │  │ │ <─── Allocated 2nd (q) ───────┘ 
│ 0x10 ──────────────── │      Since tiny size chunks, this page will contain
│   │  │  │  │  │  │  │ │      a pginfo struct placed immediately after the
│ ───────────────────── │      'large' chunks
│   │  │  │  │  │  │  │ │
└───────────────────────┘


    struct pginfo       *next;  /* next on the free list */
    void                *page;  /* Pointer to the page */
    u_short             size;   /* size of this page's chunks */
    u_short             shift;  /* How far to shift for this size chunks */
    u_short             free;   /* How many free chunks */
    u_short             total;  /* How many chunk */
    u_int               bits[1]; /* Which chunks are free */

At the time of the last malloc, there are '2' occupied chunks.
By overwritting the 'page' value of the pginfo struct with the address
of exit@got.plt-64, the next address returned by malloc will be the address of exit.

strncpy will then copy in the value contained at argv[2], replacing exit!
By pointing that to shellcode, you land a shell!

